<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        function evaluate(ast, env) {
            if (typeof ast === 'string') { // 如果 ast 是字符串，就是变量名
                return env[ast];
            } else if (typeof ast === 'number') { // 如果 ast 是数字，就是字面量
                return ast;
            } else if (ast[0] === 'quote') { // 如果 ast 是 quote，返回其第二个元素
                return ast[1];
            } else if (ast[0] === 'if') { // 如果 ast 是 if，则根据条件判断递归求值
                const [_, condition, thenClause, elseClause] = ast;
                const conditionResult = evaluate(condition, env);
                return evaluate(conditionResult ? thenClause : elseClause, env);
            } else if (ast[0] === 'def') { // 如果 ast 是 define，将其第三个元素作为变量名添加到环境中
                const [_, name, value] = ast;
                env[name] = evaluate(value, env);
            } else if (ast[0] === 'lambda') { // 如果 ast 是 lambda，创建一个新的函数，并返回
                const [_, params, body] = ast;
                return function () {
                    const args = arguments;
                    const scope = Object.create(env);
                    for (let i = 0; i < args.length; i++) {
                        scope[params[i]] = args[i];
                    }
                    return evaluate(body, scope);
                }
            } else { // 如果 ast 是函数调用，递归求值并调用函数
                const [fn, ...args] = ast.map(item => evaluate(item, env));
                return fn.apply(null, args);
            }
        }



        const env = {
            '+': (a, b) => a + b,
            '-': (a, b) => a - b,
            '*': (a, b) => a * b,
            '/': (a, b) => a / b,
            '>': (a, b) => a > b,
            '<': (a, b) => a < b,
            '>=': (a, b) => a >= b,
            '<=': (a, b) => a <= b,
            '=': (a, b) => a === b,
            'null?': (a) => a === null,
            'eq?': (a, b) => a === b,
            'car': (a) => a[0],
            'cdr': (a) => a.slice(1),
            'cons': (a, b) => [a].concat(b),
        };

        const factorial = ['lambda', ['n'], ['if', ['=', 'n', 0], 1, ['*', 'n', ['factorial', ['-', 'n', 1]]]]];

        env['factorial'] = evaluate(factorial, env); // 将函数添加到环境中

        console.log(evaluate(['factorial', 0], env)); // 输出 1
        console.log(evaluate(['factorial', 1], env)); // 输出 1
        console.log(evaluate(['factorial', 5], env)); // 输出 120

        console.log(evaluate(['+', 1, 2], env)); // 输出 3


        function syntactic_sugar(ast) {
            if (ast[0] === 'let') {
                const [_, bindings, body] = ast;
                const params = [];
                const args = [];

                for (const binding of bindings) {
                    const [name, value] = binding;
                    params.push(name);
                    args.push(value);
                }

                // 将 let 转换为 lambda 就地调用
                return [['lambda', params, body], ...args];
            } else if (Array.isArray(ast)) {
                // 递归处理嵌套的表达式
                return ast.map(syntactic_sugar);
            } else {
                return ast; // 不是表达式，直接返回
            }
        }

        // 示例用法
        const inputAst = ['let', [['x', 10], ['y', 20]], ['+', 'x', 'y']];
        const transformedAst = syntactic_sugar(inputAst);
        console.log(transformedAst);
        console.log(evaluate(transformedAst, env));


        function lispToJsArray(input) {
            let tokens = input.replace(/\(/g, ' ( ').replace(/\)/g, ' ) ').split(/\s+/).filter(token => token.length > 0);
            let stack = [];
            let output = [];

            for (let i = 0; i < tokens.length; i++) {
                let token = tokens[i];
                if (token === '(') {
                    stack.push(output);
                    output = [];
                } else if (token === ')') {
                    let lastOutput = output;
                    output = stack.pop();
                    output.push(lastOutput);
                } else {
                    if (!isNaN(parseFloat(token))) {
                        output.push(parseFloat(token));
                    } else {
                        output.push(token);
                    }
                }
            }

            return output[0];
        }

        const lispCode = `
(defun factorial (n)
  (if (= n 0)
      1
      (* n (factorial (- n 1)))))
`;

        const jsArray = lispToJsArray(lispCode);
        console.log(jsArray);



    </script>

</body>

</html>